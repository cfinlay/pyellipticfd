import numpy as np
import distmesh as dm
from scipy.spatial import ConvexHull, Delaunay

from pyellipticfd import ddi
from pyellipticfd.fdclasses import FDRegularGrid, FDTriMesh

# Test on functions with constant directional derivatives
# -------------------------------------------------------

# Set up computational domain
N = 2**4-1;
d = 2;
xi = [0,1]

shape = [N for i in range(d)]
bounds = np.array([xi for i in range(d)]).T
r = 2

G = FDRegularGrid(shape,bounds,r)
X = G.vertices[:,0]
Y = G.vertices[:,1]
if d==3:
    Z = G.vertices[:,2]
else:
    Z = 0

U2 = X**2 - Y**2 + Z**2
U1 = X - Y

if d==2:
    th = np.array([np.cos(np.pi/8), np.sin(np.pi/8)])
else:
    th = np.array([1/3,1/4,1/7])
    th /= np.linalg.norm(th)

d1, M1 = ddi.d1(G,[1,0],U1, jacobian=True)
d2, M2 = ddi.d2(G,[1,0],U2, jacobian=True)
(d2min, M_min, v_min), (d2max, M_max, v_max) = ddi.d2eigs(G,U2, jacobian=True, control=True)



# Test on circular domain for boundary normals
# --------------------------------------------
fd = lambda p : np.sqrt((p**2).sum(1))-1.0
p, _ = dm.distmesh2d(fd, dm.huniform, 0.1, (-1,-1,1,1))

# delete boundary points generated by distmesh
cvx = ConvexHull(p)
boundary = cvx.vertices
p = p[np.in1d(np.arange(p.shape[0]),boundary,invert=True)]

# replace with a finer boundary resolution
th = np.linspace(0,2*np.pi,250)
th = th[0:-1]
p = np.concatenate([p,np.array([np.cos(th),np.sin(th)]).T])
boundary = np.arange(p.shape[0]-th.size,p.shape[0])
interior = np.arange(p.shape[0]-th.size)

# Get triangulation
dly = Delaunay(p)
tri = dly.simplices

Grid = FDTriMesh(p, tri, boundary=boundary,
               interior=interior,
               angular_resolution=3/4*np.pi,
               boundary_normals=p[boundary])
U = np.linalg.norm(Grid.points, axis=1)

d1n, M_d1n = ddi.d1n(Grid, u=U, jacobian=True)
